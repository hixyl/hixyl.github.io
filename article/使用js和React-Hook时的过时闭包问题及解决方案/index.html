<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/c6771dd8c665257b.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/4d166e604f6ba619.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/99f6a99e5e57ec87.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-5297ab80a73cd07d.js" as="script"/><link rel="preload" href="/_next/static/chunks/fd9d1056-2a48348db6e9e5e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/596-38dca328e8a8de9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-app-d4767c0c82b0abc6.js" as="script"/><link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=G-N3DJ3JTVT2"/><link rel="icon" href="/favicon.png?&lt;generated&gt;" type="image/&lt;generated&gt;" sizes="&lt;generated&gt;"/><title>使用js和React Hook时的过时闭包问题及解决方案 - 流年石刻</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_e66fe9"><div class="article_pageBody__Bryg4"><div class="header_header__us6ao"><div class="header_topHeader__xNJQ1"><a href="/"><div class="header_logo__IbzcJ">流年石刻</div></a><div class="menu_menuBox__ZCxZE"><a href="/"><p style="--icon-unSelected:url(/icons/home_gray.svg);--icon-selected:url(/icons/home_black.svg)" class="menu_navListItem__znGi9">首页</p></a><a href="/articles/all/1/"><p style="--icon-unSelected:url(/icons/article_gray.svg);--icon-selected:url(/icons/article_black.svg)" class="menu_navListItemSelected__JZBTq">文章</p></a><a href="/about/"><p style="--icon-unSelected:url(/icons/about_gray.svg);--icon-selected:url(/icons/about_black.svg)" class="menu_navListItem__znGi9">关于</p></a><a href="/search/"><p style="--icon-unSelected:url(/icons/search_gray.svg);--icon-selected:url(/icons/search_black.svg)" class="menu_navListItem__znGi9">搜索</p></a></div><div class="header_iconArea__Co05n"><img alt="menu" loading="lazy" width="30" height="30" decoding="async" data-nimg="1" class="header_menuIcon__7dQN0" style="color:transparent" src="/_next/static/media/menu.c309d6d5.svg"/></div></div><div class="mobileMenu_mobileMenu__Mz_1e mobileMenu_menuContainer__hndoP "><a href="/"><div style="--icon-unSelected:url(/icons/home_gray.svg);--icon-selected:url(/icons/home_black.svg)" class="mobileMenu_item__pY1st ">首页</div></a><a href="/articles/all/1/"><div style="--icon-unSelected:url(/icons/article_gray.svg);--icon-selected:url(/icons/article_black.svg)" class="mobileMenu_item__pY1st mobileMenu_itemSelected__d5YAL">文章</div></a><a href="/about/"><div style="--icon-unSelected:url(/icons/about_gray.svg);--icon-selected:url(/icons/about_black.svg)" class="mobileMenu_item__pY1st ">关于</div></a><a href="/search/"><div style="--icon-unSelected:url(/icons/search_gray.svg);--icon-selected:url(/icons/search_black.svg)" class="mobileMenu_item__pY1st ">搜索</div></a></div></div><div class="article_pageBodyMain___x_AF"><div class="sidebar_sidebar__6HDFv sidebar_open__ia_Zv"><div class="sidebar_sidebarInner__NiyBR"><div class="topImgBox_topImgBox__2OSEr"><img alt="" loading="lazy" width="1024" height="1024" decoding="async" data-nimg="1" class="topImgBox_topImg__6hmTH" style="color:transparent" src="/_next/static/media/author.2cacf696.jpg"/><div class="topImgBox_textArea__iSnnz"><div class="topImgBox_author__URTnh">星玉龙</div><div class="topImgBox_position__7qz_f">前端工程师</div><a class="topImgBox_email__skkTy" href="mailto:me@timeshike.com">me@timeshike.com</a><a class="topImgBox_githubBtn__YYbAh" href="https://github.com/hixyl">Github</a><div class="topImgBox_content__lmDiZ">闲云潭影，物换星移<br/>滕王高阁，几度春秋<br/>故人不在，长江空流<br/>月圆复缺，岁月悠悠<br/></div><div class="topImgBox_bottomBtns__EIkFU"><a href="/atom.xml"><img alt="rss" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/rss.d066fc0f.svg"/></a></div></div></div></div><div class="sidebar_btnArea__Wtf3d"><div class="sidebar_btnRect__RQ7s5"><img alt="rightArray" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="sidebar_imgBtn__gmp3y" style="color:transparent" src="/_next/static/media/left_array.0dce0964.svg"/></div></div></div><div class="article_articleContainer__uRwUh scrollContent"><div class="article_articleBody__0coIY scrollContent"><h1 style="margin-bottom:0.1rem;margin-top:0.2rem">使用js和React Hook时的过时闭包问题及解决方案</h1><div><div class="tags_tags__qM_Ja"><p class="tags_label__Rg6b2">分类</p><a href="/articles/新知笔记/1/"><p class="tags_tag__HZYxk tags_tagLink__gnw9V">新知笔记</p></a><a href="/articles/前端技术/1/"><p class="tags_tag__HZYxk tags_tagLink__gnw9V">前端技术</p></a></div><div class="tags_tags__qM_Ja"><p class="tags_label__Rg6b2">标签</p><p class="tags_tag__HZYxk ">javascript</p><p class="tags_tag__HZYxk ">React</p><p class="tags_tag__HZYxk ">过时闭包</p><p class="tags_tag__HZYxk ">Hook</p><p class="tags_tag__HZYxk ">解决方案</p></div><div class="walinePageView_walinePageview__C8Aml"><img alt="" loading="lazy" width="25" height="25" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/eye.7eadf26d.svg"/><span style="font-size:0.9rem;color:gray" class="waline-pageview-count"></span></div></div><article>
    <p class="time">发布时间：<time datetime="20 October, 2023">2023-10-20 16:40:29</time></p>
    <p class="words">本文字数：1,764 字       阅读完需：约 4 分钟</p>
    <html><head></head><body><h2>1. JS 中的闭包</h2>
<p>下面定义了一个工厂函数 <code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">(i)</span></span></code>，它返回一个<code><span class="hljs-attribute">increment</span></code>函数。之后，每次调用<code><span class="hljs-attribute">increment</span></code>函数时，内部计数器的值都会增加<code><span class="hljs-selector-tag">i</span></code>。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrement</span>(<span class="hljs-params">i</span>) {
  <span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    value += i;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
  }
  <span class="hljs-keyword">return</span> increment;
}

<span class="hljs-keyword">const</span> inc = <span class="hljs-title function_">createIncrement</span>(<span class="hljs-number">1</span>);
<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 1</span>
<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 2</span>
</code></pre>
<p><code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span></code> 返回一个增量函数，该函数赋值给<code><span class="hljs-keyword">inc</span></code>变量。当调用<code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>时，<code><span class="hljs-attribute">value</span></code> 变量加<code>1</code>。</p>
<p>第一次调用<code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>返回<code>1</code>，第二次调用返回<code>2</code>，依此类推。</p>
<p>这挺趣的，只要调用<code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>还不带参数，JS 仍然知道当前 <code><span class="hljs-attribute">value</span></code> 和 <code><span class="hljs-selector-tag">i</span></code> 的增量，来看看这玩意是如何工作的。</p>
<p>原理就在 <code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">()</span></span></code> 中。当在函数上返回一个函数时，有会有闭包产生。闭包捕获词法作用域中的变量 <code><span class="hljs-attribute">value</span></code> 和 <code><span class="hljs-selector-tag">i</span></code>。</p>
<p>词法作用域是定义闭包的外部作用域。在本例中，<code><span class="hljs-function"><span class="hljs-title">increment</span><span class="hljs-params">()</span></span></code> 的词法作用域是<code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">()</span></span></code>的作用域，其中包含变量 <code><span class="hljs-attribute">value</span></code> 和 <code><span class="hljs-selector-tag">i</span></code>。</p>
<p><img src="guoshibibao1.png" alt=""></p>
<p>无论在何处调用 <code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>，甚至在 <code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">()</span></span></code> 的作用域之外，它都可以访问 <code><span class="hljs-attribute">value</span></code> 和 <code><span class="hljs-selector-tag">i</span></code>。</p>
<blockquote>
<p>闭包是一个可以从其词法作用域记住和修改变量的函数，不管执行作用域是什么。</p>
</blockquote>
<p>继续这个例子，可以在任何地方调用 <code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>，甚至在异步回调中也可以:</p>
<pre><code class="language-javascript">(function() {
  <span class="hljs-built_in">inc</span>(); <span class="hljs-comment">// 3</span>
}());

<span class="hljs-built_in">setTimeout</span>(function() {
  <span class="hljs-built_in">inc</span>(); <span class="hljs-comment">// 4</span>
}, <span class="hljs-number">1000</span>);
</code></pre>
<h2>2. React Hooks 中的闭包</h2>
<p>通过简化状态重用和副作用管理，Hooks 取代了基于类的组件。此外，咱们可以将重复的逻辑提取到自定义 Hook 中，以便在应用程序之间重用。</p>
<p>Hooks 严重依赖于 JS 闭包,但是闭包有时很棘手。</p>
<p>当咱们使用一个有多种副作用和状态管理的 React 组件时，可能会遇到的一个问题是过时的闭包，这可能很难解决。</p>
<p>咱们从提炼出过时的闭包开始。然后，看看过时的闭包如何影响 React Hook，以及如何解决这个问题。</p>
<h2>3. 过时的闭包</h2>
<p>工厂函数<code><span class="hljs-function"><span class="hljs-title">createIncrement</span><span class="hljs-params">(i)</span></span></code>返回一个<code><span class="hljs-attribute">increment</span></code>函数。<code><span class="hljs-attribute">increment</span></code> 函数对 <code><span class="hljs-attribute">value</span></code> 增加i<code>请输入代码</code> ，并返回一个记录当前 <code><span class="hljs-attribute">value</span></code> 的函数</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrement</span>(<span class="hljs-params">i</span>) {
  let value = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    value += i;
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);
    const message = <span class="hljs-string">`Current value is <span class="hljs-subst">${value}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">logValue</span>(<span class="hljs-params"></span>) {
      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(message);
    };
  }
  
  <span class="hljs-keyword">return</span> increment;
}

const inc = createIncrement(<span class="hljs-number">1</span>);
const <span class="hljs-built_in">log</span> = inc(); <span class="hljs-comment">// 打印 1</span>
inc();             <span class="hljs-comment">// 打印 2</span>
inc();             <span class="hljs-comment">// 打印 3</span>
<span class="hljs-comment">// 无法正确工作</span>
<span class="hljs-built_in">log</span>();             <span class="hljs-comment">// 打印 "Current value is 1"</span>
</code></pre>
<p>在第一次调用<code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code>时，返回的闭包被分配给变量 <code><span class="hljs-built_in">log</span></code>。对 <code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code> 的 <code>3</code> 次调用的增量 <code><span class="hljs-attribute">value</span></code> 为 <code>3</code>。</p>
<p>最后，调用<code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 打印 message <code>“<span class="hljs-keyword">Current</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>”</code>，这是出乎意料的，因为此时 <code><span class="hljs-attribute">value</span></code> 等于 <code>3</code>。</p>
<p><code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code>是过时的闭包。在第一次调用 <code><span class="hljs-function"><span class="hljs-title">inc</span><span class="hljs-params">()</span></span></code> 时，闭包 <code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 捕获了具有 <code>“<span class="hljs-keyword">Current</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>”</code> 的 <code><span class="hljs-keyword">message</span></code> 变量。而现在，当 <code><span class="hljs-attribute">value</span></code> 已经是 <code>3</code> 时，<code><span class="hljs-keyword">message</span></code> 变量已经过时了。</p>
<blockquote>
<p>过时的闭包捕获具有过时值的变量。</p>
</blockquote>
<h2>4.修复过时闭包的问题</h2>
<h4>使用新的闭包</h4>
<p>解决过时闭包的第一种方法是找到捕获最新变量的闭包。</p>
<p>咱们找到捕获了最新 <code><span class="hljs-keyword">message</span></code> 变量的闭包。就是从最后一次调用 inc() 返回的闭包。</p>
<pre><code class="language-javascript">const inc <span class="hljs-operator">=</span> createIncrement(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>

inc()<span class="hljs-comment">;  // 打印 1</span>
inc()<span class="hljs-comment">;  // 打印 2</span>
const latestLog <span class="hljs-operator">=</span> inc()<span class="hljs-comment">; // 打印 3</span>
// 正常工作
latestLog()<span class="hljs-comment">; // 打印 "Current value is 3"</span>
</code></pre>
<p><code><span class="hljs-attribute">latestLog</span></code> 捕获的 <code><span class="hljs-keyword">message</span></code> 变量具有最新的的值 “Current value is 3”。</p>
<p>顺便说一下，这大概就是 React Hook 处理闭包新鲜度的方式。</p>
<p>Hooks 实现假设在组件重新渲染之间，作为 Hook 回调提供的最新闭包(例如 <code><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(callback)</span></span></code>) 已经从组件的函数作用域捕获了最新的变量。</p>
<h4>关闭已更改的变量</h4>
<p>第二种方法是让<code><span class="hljs-function"><span class="hljs-title">logValue</span><span class="hljs-params">()</span></span></code>直接使用 <code><span class="hljs-attribute">value</span></code>。</p>
<p>让我们移动行 <code>const message <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span></code> 到 <code><span class="hljs-function"><span class="hljs-title">logValue</span><span class="hljs-params">()</span></span></code> 函数体中：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrementFixed</span>(<span class="hljs-params">i</span>) {
  let value = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    value += i;
    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">logValue</span>(<span class="hljs-params"></span>) {
      const message = <span class="hljs-string">`Current value is <span class="hljs-subst">${value}</span>`</span>;
      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(message);
    };
  }
  
  <span class="hljs-keyword">return</span> increment;
}

const inc = createIncrementFixed(<span class="hljs-number">1</span>);
const <span class="hljs-built_in">log</span> = inc(); <span class="hljs-comment">// 打印 1</span>
inc();             <span class="hljs-comment">// 打印 2</span>
inc();             <span class="hljs-comment">// 打印 3</span>
<span class="hljs-comment">// 正常工作</span>
<span class="hljs-built_in">log</span>();             <span class="hljs-comment">// 打印 "Current value is 3"</span>
</code></pre>
<p><code><span class="hljs-function"><span class="hljs-title">logValue</span><span class="hljs-params">()</span></span></code> 关闭 <code><span class="hljs-function"><span class="hljs-title">createIncrementFixed</span><span class="hljs-params">()</span></span></code> 作用域内的 <code><span class="hljs-attribute">value</span></code> 变量。<code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 现在打印正确的消息“<code><span class="hljs-keyword">Current</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> <span class="hljs-number">3</span></code>”。</p>
<h2>5. Hook 中过时的闭包</h2>
<h4>useEffect()</h4>
<p>现在来研究一下在使用 <code><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">()</span></span></code> Hook 时出现过时闭包的常见情况。</p>
<p>在组件 <code><span class="hljs-section">&lt;WatchCount&gt;</span></code> 中，<code><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">()</span></span></code>每秒打印 <code><span class="hljs-built_in">count</span></code> 的值。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">WatchCount</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${count}</span>`</span>);
    }, <span class="hljs-number">2000</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1) }&gt;
        加1
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>打开 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-broken-2-gyhzk">CodeSandbox</a> 并单击几次<strong>加1</strong>按钮。然后看看控制台，每2秒打印 <code>Count <span class="hljs-keyword">is</span>: <span class="hljs-number">0</span></code>。</p>
<p>咋这样呢？</p>
<p>在第一次渲染时，<code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 中闭包捕获 <code><span class="hljs-built_in">count</span></code> 变量的值 <code>0</code>。过后，即使 <code><span class="hljs-built_in">count</span></code> 增加，<code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code>中使用的仍然是初始化的值 <code>0</code>。<code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 中的闭包是一个过时的闭包。</p>
<p>解决方案是让 <code><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">()</span></span></code>知道 <code><span class="hljs-function"><span class="hljs-title">log</span><span class="hljs-params">()</span></span></code> 中的闭包依赖于<code><span class="hljs-built_in">count</span></code>：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">WatchCount</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${count}</span>`</span>);
    }, <span class="hljs-number">2000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-built_in">clearInterval</span>(id);
    }
  }, [count]); <span class="hljs-comment">// 看这里，这行是重点</span>

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1) }&gt;
        Increase
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>适当地设置依赖项后，一旦 <code><span class="hljs-built_in">count</span></code> 更改，<code><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">()</span></span></code> 就更新闭包。</p>
<p>同样打开修复的 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-fixed-2-ybv47">codesandbox</a>，单击几次<strong>加1</strong>按钮。然后看看控制台，这次打印就是正确的值了。</p>
<p>正确管理 Hook 依赖关系是解决过时闭包问题的关键。推荐安装 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react-hooks">eslint-plugin-react-hooks</a>,它可以帮助咱们检测被遗忘的依赖项。</p>
<h4>useState()</h4>
<p>组件<code><span class="hljs-section">&lt;DelayedCount&gt;</span></code>有 2 个按钮：</p>
<ul>
<li>点击按键 <strong>“Increase async”</strong> 在异步模式下以<code>1</code>秒的延迟递增计数器</li>
</ul>
<pre><code class="language-js"> 在同步模式下，点击按键 “<span class="hljs-title class_">Increase</span> sync” 会立即增加计数器。
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedCount</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClickAsync</span>(<span class="hljs-params"></span>) {
 <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) {   <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); }, <span class="hljs-number">1000</span>);
 }
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClickSync</span>(<span class="hljs-params"></span>) {
 <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
 }
 <span class="hljs-keyword">return</span> (
 <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>   {count}   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClickAsync}</span>&gt;</span>Increase async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClickSync}</span>&gt;</span>Increase sync<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
 );
}
 
</code></pre>
<p>现在<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fuse-state-broken-0q994">打开 codesandbox 演示</a>。点击 <strong>“Increase async”</strong> 按键然后立即点击 <strong>“Increase sync”</strong> 按钮，<code><span class="hljs-built_in">count</span></code> 只更新到 <code>1</code>。</p>
<p>这是因为 <code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 是一个过时的闭包。</p>
<p>来看看这个过程发生了什么：</p>
<ol>
<li>初始渲染：<code><span class="hljs-built_in">count</span></code> 值为 <code>0</code>。</li>
<li>点击 <strong>'Increase async'</strong> 按钮。<code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 闭包捕获 <code><span class="hljs-built_in">count</span></code> 的值 <code>0</code>。<code><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">()</span></span></code> 1 秒后调用 <code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code>。</li>
<li>点击 <strong>“Increase async”</strong> 按键。<code><span class="hljs-function"><span class="hljs-title">handleClickSync</span><span class="hljs-params">()</span></span></code> 调用 <code><span class="hljs-function"><span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-number">0</span> + <span class="hljs-number">1</span>)</span></span></code> 将 <code><span class="hljs-built_in">count</span></code> 的值设置为 <code>1</code>，组件重新渲染。</li>
<li><code>1</code> 秒之后，<code><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">()</span></span></code> 执行 <code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 函数。但是 <code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 中闭包保存 <code><span class="hljs-built_in">count</span></code> 的值是初始渲染的值 <code>0</code>，所以调用 <code><span class="hljs-function"><span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-number">0</span> + <span class="hljs-number">1</span>)</span></span></code>，结果<code><span class="hljs-built_in">count</span></code>保持为 <code>1</code>。</li>
</ol>
<p><code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 是一个过时的闭包，它使用在初始渲染期间捕获的过时的 <code><span class="hljs-built_in">count</span></code> 变量。</p>
<p>为了解决这个问题，可以使用函数方法来更新 <code><span class="hljs-built_in">count</span></code> 状态：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedCount</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClickAsync</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">count</span> =&gt;</span> count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 这行是重点</span>
    }, <span class="hljs-number">1000</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClickSync</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClickAsync}</span>&gt;</span>Increase async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClickSync}</span>&gt;</span>Increase sync<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>现在 <code>setCount(<span class="hljs-function"><span class="hljs-params">count</span> =&gt;</span> <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>)</code> 更新了 <code><span class="hljs-function"><span class="hljs-title">delay</span><span class="hljs-params">()</span></span></code> 中的 <code><span class="hljs-built_in">count</span></code> 状态。React 确保将最新状态值作为参数提供给更新状态函数，过时的闭包的问题就解决了。</p>
<h2>总结</h2>
<p>闭包是一个函数，它从定义变量的地方(或其词法范围)捕获变量。闭包是每个 JS 开发人员都应该知道的一个重要概念。</p>
<p>当闭包捕获过时的变量时，就会出现过时闭包的问题。解决过时闭包的一个有效方法是正确设置 React Hook 的依赖项。或者，对于过时的状态，使用函数方式更新状态。</p>
<p>你认为闭包使得 React Hook 很难理解吗？</p>
<h2>来源</h2>
<blockquote>
<p>作者：Dmitri Pavlutin<br>
译者：前端小智<br>
来源：dmitripavlutin<br>
原文： <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F">https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F</a></p>
</blockquote>
</body></html>
  </article><div class="Toastify"></div><div></div><div class="bottomBar_bottomBar__uHU1W"><div class="bottomBar_text__iz3cM">Powerd by<a href="https://github.com/hixyl/YlBlog" target="_blank"> YlBlog(玉龙博客)</a></div></div></div></div></div></div><script src="/_next/static/chunks/webpack-5297ab80a73cd07d.js" async=""></script><script src="/_next/static/chunks/fd9d1056-2a48348db6e9e5e0.js" async=""></script><script src="/_next/static/chunks/596-38dca328e8a8de9d.js" async=""></script><script src="/_next/static/chunks/main-app-d4767c0c82b0abc6.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/c6771dd8c665257b.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/4d166e604f6ba619.css\",{\"as\":\"style\"}]\n5:HL[\"/_next/static/css/99f6a99e5e57ec87.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"6:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-5297ab80a73cd07d.js\",\"971:static/chunks/fd9d1056-2a48348db6e9e5e0.js\",\"596:static/chunks/596-38dca328e8a8de9d.js\"],\"name\":\"default\",\"async\":false}\n8:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-5297ab80a73cd07d.js\",\"971:static/chunks/fd9d1056-2a48348db6e9e5e0.js\",\"596:static/chunks/596-38dca328e8a8de9d.js\"],\"name\":\"GlobalError\",\"async\":false}\n9:I{\"id\":3015,\"chunks\":[\"185:static/chunks/app/layout-1c7fcb8e096f7f78.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":77"])</script><script>self.__next_f.push([1,"67,\"chunks\":[\"272:static/chunks/webpack-5297ab80a73cd07d.js\",\"971:static/chunks/fd9d1056-2a48348db6e9e5e0.js\",\"596:static/chunks/596-38dca328e8a8de9d.js\"],\"name\":\"default\",\"async\":false}\nb:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-5297ab80a73cd07d.js\",\"971:static/chunks/fd9d1056-2a48348db6e9e5e0.js\",\"596:static/chunks/596-38dca328e8a8de9d.js\"],\"name\":\"default\",\"async\":false}\nd:I{\"id\":5345,\"chunks\":[\"185:static/chunks/app/layout-1c7fcb8e096f7f78.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c6771dd8c665257b.css\",\"precedence\":\"next\"}]],[\"$\",\"$L6\",null,{\"buildId\":\"b9a8PnxJ6T87cYHNh85eN\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/article/%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/\",\"initialTree\":[\"\",{\"children\":[\"article\",{\"children\":[[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"],{\"children\":[\"__PAGE__?{\\\"id\\\":\\\"使用js和React-Hook时的过时闭包问题及解决方案\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":\"$L7\",\"globalErrorComponent\":\"$8\",\"children\":[[\"$\",\"html\",null,{\"lang\":\"zh\",\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png?\u003cgenerated\u003e\",\"type\":\"image/\u003cgenerated\u003e\",\"sizes\":\"\u003cgenerated\u003e\"}],[\"$\",\"$L9\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-N3DJ3JTVT2\"}],[\"$\",\"$L9\",null,{\"id\":\"google-analytics\",\"children\":\"\\n          window.dataLayer = window.dataLayer || [];\\n          function gtag(){dataLayer.push(arguments);}\\n          gtag('js', new Date());\\n        \\n          gtag('config', 'G-N3DJ3JTVT2');\\n        \"}],[\"$\",\"body\",null,{\"className\":\"__className_e66fe9\",\"children\":[[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"article\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"article\",\"children\",[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lc\",null],\"segment\":\"__PAGE__?{\\\"id\\\":\\\"使用js和React-Hook时的过时闭包问题及解决方案\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4d166e604f6ba619.css\",\"precedence\":\"next\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/99f6a99e5e57ec87.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"]},\"styles\":[]}],\"segment\":\"article\"},\"styles\":[]}],[\"$\",\"$Ld\",null,{}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"e:I{\"id\":4733,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\nf:I{\"id\":6697,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681"])</script><script>self.__next_f.push([1,":static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\n10:I{\"id\":6685,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":fals"])</script><script>self.__next_f.push([1,"e}\n11:I{\"id\":9777,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\n13:I{\"id\":5529,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\""])</script><script>self.__next_f.push([1,",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\n14:I{\"id\":1848,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"Waline\",\""])</script><script>self.__next_f.push([1,"async\":false}\n15:I{\"id\":2953,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\n16:I{\"id\":633,\"chunks\":[\"577:static/chunks/221e729c-eb04291402bd74ea.js\",\"231:static/chunks/9316e0b3-06fce1d7b5082435.js\",\"165:static/chunks/165-9f67d2f80e"])</script><script>self.__next_f.push([1,"9188a0.js\",\"681:static/chunks/681-a175b8ff92d72522.js\",\"945:static/chunks/945-dd57d3732d1beca5.js\",\"241:static/chunks/app/article/[id]/page-18aa656a1117c673.js\"],\"name\":\"\",\"async\":false}\n12:T6bf9,"])</script><script>self.__next_f.push([1,"\n    \u003cp class=\"time\"\u003e发布时间：\u003ctime datetime=\"20 October, 2023\"\u003e2023-10-20 16:40:29\u003c/time\u003e\u003c/p\u003e\n    \u003cp class=\"words\"\u003e本文字数：1,764 字       阅读完需：约 4 分钟\u003c/p\u003e\n    \u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003ch2\u003e1. JS 中的闭包\u003c/h2\u003e\n\u003cp\u003e下面定义了一个工厂函数 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(i)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e，它返回一个\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003eincrement\u003c/span\u003e\u003c/code\u003e函数。之后，每次调用\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003eincrement\u003c/span\u003e\u003c/code\u003e函数时，内部计数器的值都会增加\u003ccode\u003e\u003cspan class=\"hljs-selector-tag\"\u003ei\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateIncrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    value += i;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e increment;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inc = \u003cspan class=\"hljs-title function_\"\u003ecreateIncrement\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003einc\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003einc\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 返回一个增量函数，该函数赋值给\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003einc\u003c/span\u003e\u003c/code\u003e变量。当调用\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e时，\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 变量加\u003ccode\u003e1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e第一次调用\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e返回\u003ccode\u003e1\u003c/code\u003e，第二次调用返回\u003ccode\u003e2\u003c/code\u003e，依此类推。\u003c/p\u003e\n\u003cp\u003e这挺趣的，只要调用\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e还不带参数，JS 仍然知道当前 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 和 \u003ccode\u003e\u003cspan class=\"hljs-selector-tag\"\u003ei\u003c/span\u003e\u003c/code\u003e 的增量，来看看这玩意是如何工作的。\u003c/p\u003e\n\u003cp\u003e原理就在 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中。当在函数上返回一个函数时，有会有闭包产生。闭包捕获词法作用域中的变量 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 和 \u003ccode\u003e\u003cspan class=\"hljs-selector-tag\"\u003ei\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e词法作用域是定义闭包的外部作用域。在本例中，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003eincrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 的词法作用域是\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e的作用域，其中包含变量 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 和 \u003ccode\u003e\u003cspan class=\"hljs-selector-tag\"\u003ei\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"guoshibibao1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e无论在何处调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e，甚至在 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 的作用域之外，它都可以访问 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 和 \u003ccode\u003e\u003cspan class=\"hljs-selector-tag\"\u003ei\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e闭包是一个可以从其词法作用域记住和修改变量的函数，不管执行作用域是什么。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e继续这个例子，可以在任何地方调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e，甚至在异步回调中也可以:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e(function() {\n  \u003cspan class=\"hljs-built_in\"\u003einc\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n}());\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(function() {\n  \u003cspan class=\"hljs-built_in\"\u003einc\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n}, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. React Hooks 中的闭包\u003c/h2\u003e\n\u003cp\u003e通过简化状态重用和副作用管理，Hooks 取代了基于类的组件。此外，咱们可以将重复的逻辑提取到自定义 Hook 中，以便在应用程序之间重用。\u003c/p\u003e\n\u003cp\u003eHooks 严重依赖于 JS 闭包,但是闭包有时很棘手。\u003c/p\u003e\n\u003cp\u003e当咱们使用一个有多种副作用和状态管理的 React 组件时，可能会遇到的一个问题是过时的闭包，这可能很难解决。\u003c/p\u003e\n\u003cp\u003e咱们从提炼出过时的闭包开始。然后，看看过时的闭包如何影响 React Hook，以及如何解决这个问题。\u003c/p\u003e\n\u003ch2\u003e3. 过时的闭包\u003c/h2\u003e\n\u003cp\u003e工厂函数\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrement\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(i)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e返回一个\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003eincrement\u003c/span\u003e\u003c/code\u003e函数。\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003eincrement\u003c/span\u003e\u003c/code\u003e 函数对 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 增加i\u003ccode\u003e请输入代码\u003c/code\u003e ，并返回一个记录当前 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 的函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateIncrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e) {\n  let value = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    value += i;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e(value);\n    const message = \u003cspan class=\"hljs-string\"\u003e`Current value is \u003cspan class=\"hljs-subst\"\u003e${value}\u003c/span\u003e`\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e(message);\n    };\n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e increment;\n}\n\nconst inc = createIncrement(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\nconst \u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e = inc(); \u003cspan class=\"hljs-comment\"\u003e// 打印 1\u003c/span\u003e\ninc();             \u003cspan class=\"hljs-comment\"\u003e// 打印 2\u003c/span\u003e\ninc();             \u003cspan class=\"hljs-comment\"\u003e// 打印 3\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 无法正确工作\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e();             \u003cspan class=\"hljs-comment\"\u003e// 打印 \"Current value is 1\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在第一次调用\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e时，返回的闭包被分配给变量 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e\u003c/code\u003e。对 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 的 \u003ccode\u003e3\u003c/code\u003e 次调用的增量 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 为 \u003ccode\u003e3\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e最后，调用\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 打印 message \u003ccode\u003e“\u003cspan class=\"hljs-keyword\"\u003eCurrent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evalue\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e”\u003c/code\u003e，这是出乎意料的，因为此时 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 等于 \u003ccode\u003e3\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e是过时的闭包。在第一次调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003einc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 时，闭包 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 捕获了具有 \u003ccode\u003e“\u003cspan class=\"hljs-keyword\"\u003eCurrent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evalue\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e”\u003c/code\u003e 的 \u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003emessage\u003c/span\u003e\u003c/code\u003e 变量。而现在，当 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 已经是 \u003ccode\u003e3\u003c/code\u003e 时，\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003emessage\u003c/span\u003e\u003c/code\u003e 变量已经过时了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e过时的闭包捕获具有过时值的变量。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e4.修复过时闭包的问题\u003c/h2\u003e\n\u003ch4\u003e使用新的闭包\u003c/h4\u003e\n\u003cp\u003e解决过时闭包的第一种方法是找到捕获最新变量的闭包。\u003c/p\u003e\n\u003cp\u003e咱们找到捕获了最新 \u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003emessage\u003c/span\u003e\u003c/code\u003e 变量的闭包。就是从最后一次调用 inc() 返回的闭包。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst inc \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e createIncrement(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\u003cspan class=\"hljs-comment\"\u003e;\u003c/span\u003e\n\ninc()\u003cspan class=\"hljs-comment\"\u003e;  // 打印 1\u003c/span\u003e\ninc()\u003cspan class=\"hljs-comment\"\u003e;  // 打印 2\u003c/span\u003e\nconst latestLog \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e inc()\u003cspan class=\"hljs-comment\"\u003e; // 打印 3\u003c/span\u003e\n// 正常工作\nlatestLog()\u003cspan class=\"hljs-comment\"\u003e; // 打印 \"Current value is 3\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003elatestLog\u003c/span\u003e\u003c/code\u003e 捕获的 \u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003emessage\u003c/span\u003e\u003c/code\u003e 变量具有最新的的值 “Current value is 3”。\u003c/p\u003e\n\u003cp\u003e顺便说一下，这大概就是 React Hook 处理闭包新鲜度的方式。\u003c/p\u003e\n\u003cp\u003eHooks 实现假设在组件重新渲染之间，作为 Hook 回调提供的最新闭包(例如 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(callback)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e) 已经从组件的函数作用域捕获了最新的变量。\u003c/p\u003e\n\u003ch4\u003e关闭已更改的变量\u003c/h4\u003e\n\u003cp\u003e第二种方法是让\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elogValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e直接使用 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e让我们移动行 \u003ccode\u003econst message \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e ...\u003cspan class=\"hljs-comment\"\u003e;\u003c/span\u003e\u003c/code\u003e 到 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elogValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 函数体中：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateIncrementFixed\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e) {\n  let value = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    value += i;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e(value);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      const message = \u003cspan class=\"hljs-string\"\u003e`Current value is \u003cspan class=\"hljs-subst\"\u003e${value}\u003c/span\u003e`\u003c/span\u003e;\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e(message);\n    };\n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e increment;\n}\n\nconst inc = createIncrementFixed(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\nconst \u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e = inc(); \u003cspan class=\"hljs-comment\"\u003e// 打印 1\u003c/span\u003e\ninc();             \u003cspan class=\"hljs-comment\"\u003e// 打印 2\u003c/span\u003e\ninc();             \u003cspan class=\"hljs-comment\"\u003e// 打印 3\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 正常工作\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e();             \u003cspan class=\"hljs-comment\"\u003e// 打印 \"Current value is 3\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elogValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 关闭 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ecreateIncrementFixed\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 作用域内的 \u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003evalue\u003c/span\u003e\u003c/code\u003e 变量。\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 现在打印正确的消息“\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eCurrent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evalue\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\u003c/code\u003e”。\u003c/p\u003e\n\u003ch2\u003e5. Hook 中过时的闭包\u003c/h2\u003e\n\u003ch4\u003euseEffect()\u003c/h4\u003e\n\u003cp\u003e现在来研究一下在使用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e Hook 时出现过时闭包的常见情况。\u003c/p\u003e\n\u003cp\u003e在组件 \u003ccode\u003e\u003cspan class=\"hljs-section\"\u003e\u0026lt;WatchCount\u0026gt;\u003c/span\u003e\u003c/code\u003e 中，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e每秒打印 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eWatchCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Count is: \u003cspan class=\"hljs-subst\"\u003e${count}\u003c/span\u003e`\u003c/span\u003e);\n    }, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      {count}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u0026gt;\u003c/span\u003e setCount(count + 1) }\u0026gt;\n        加1\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打开 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-broken-2-gyhzk\"\u003eCodeSandbox\u003c/a\u003e 并单击几次\u003cstrong\u003e加1\u003c/strong\u003e按钮。然后看看控制台，每2秒打印 \u003ccode\u003eCount \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e咋这样呢？\u003c/p\u003e\n\u003cp\u003e在第一次渲染时，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中闭包捕获 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 变量的值 \u003ccode\u003e0\u003c/code\u003e。过后，即使 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 增加，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e中使用的仍然是初始化的值 \u003ccode\u003e0\u003c/code\u003e。\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中的闭包是一个过时的闭包。\u003c/p\u003e\n\u003cp\u003e解决方案是让 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e知道 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003elog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中的闭包依赖于\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eWatchCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e id = \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Count is: \u003cspan class=\"hljs-subst\"\u003e${count}\u003c/span\u003e`\u003c/span\u003e);\n    }, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-built_in\"\u003eclearInterval\u003c/span\u003e(id);\n    }\n  }, [count]); \u003cspan class=\"hljs-comment\"\u003e// 看这里，这行是重点\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      {count}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u0026gt;\u003c/span\u003e setCount(count + 1) }\u0026gt;\n        Increase\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e适当地设置依赖项后，一旦 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 更改，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 就更新闭包。\u003c/p\u003e\n\u003cp\u003e同样打开修复的 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-fixed-2-ybv47\"\u003ecodesandbox\u003c/a\u003e，单击几次\u003cstrong\u003e加1\u003c/strong\u003e按钮。然后看看控制台，这次打印就是正确的值了。\u003c/p\u003e\n\u003cp\u003e正确管理 Hook 依赖关系是解决过时闭包问题的关键。推荐安装 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react-hooks\"\u003eeslint-plugin-react-hooks\u003c/a\u003e,它可以帮助咱们检测被遗忘的依赖项。\u003c/p\u003e\n\u003ch4\u003euseState()\u003c/h4\u003e\n\u003cp\u003e组件\u003ccode\u003e\u003cspan class=\"hljs-section\"\u003e\u0026lt;DelayedCount\u0026gt;\u003c/span\u003e\u003c/code\u003e有 2 个按钮：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e点击按键 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 在异步模式下以\u003ccode\u003e1\u003c/code\u003e秒的延迟递增计数器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e 在同步模式下，点击按键 “\u003cspan class=\"hljs-title class_\"\u003eIncrease\u003c/span\u003e sync” 会立即增加计数器。\n \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDelayedCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClickAsync\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {   \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); }, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n }\n \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClickSync\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e   {count}   \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClickAsync}\u003c/span\u003e\u0026gt;\u003c/span\u003eIncrease async\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e   \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClickSync}\u003c/span\u003e\u0026gt;\u003c/span\u003eIncrease sync\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n );\n}\n \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在\u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fuse-state-broken-0q994\"\u003e打开 codesandbox 演示\u003c/a\u003e。点击 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 按键然后立即点击 \u003cstrong\u003e“Increase sync”\u003c/strong\u003e 按钮，\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 只更新到 \u003ccode\u003e1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这是因为 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 是一个过时的闭包。\u003c/p\u003e\n\u003cp\u003e来看看这个过程发生了什么：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e初始渲染：\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 值为 \u003ccode\u003e0\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003e'Increase async'\u003c/strong\u003e 按钮。\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 闭包捕获 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 的值 \u003ccode\u003e0\u003c/code\u003e。\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003esetTimeout\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 1 秒后调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 按键。\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003ehandleClickSync\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003esetCount\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 将 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 的值设置为 \u003ccode\u003e1\u003c/code\u003e，组件重新渲染。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1\u003c/code\u003e 秒之后，\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003esetTimeout\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 执行 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 函数。但是 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中闭包保存 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 的值是初始渲染的值 \u003ccode\u003e0\u003c/code\u003e，所以调用 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003esetState\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e，结果\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e保持为 \u003ccode\u003e1\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 是一个过时的闭包，它使用在初始渲染期间捕获的过时的 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 变量。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，可以使用函数方法来更新 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDelayedCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClickAsync\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ecount\u003c/span\u003e =\u0026gt;\u003c/span\u003e count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 这行是重点\u003c/span\u003e\n    }, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClickSync\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      {count}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClickAsync}\u003c/span\u003e\u0026gt;\u003c/span\u003eIncrease async\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClickSync}\u003c/span\u003e\u0026gt;\u003c/span\u003eIncrease sync\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在 \u003ccode\u003esetCount(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ecount\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\u003c/code\u003e 更新了 \u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003edelay\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e 中的 \u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e\u003c/code\u003e 状态。React 确保将最新状态值作为参数提供给更新状态函数，过时的闭包的问题就解决了。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e闭包是一个函数，它从定义变量的地方(或其词法范围)捕获变量。闭包是每个 JS 开发人员都应该知道的一个重要概念。\u003c/p\u003e\n\u003cp\u003e当闭包捕获过时的变量时，就会出现过时闭包的问题。解决过时闭包的一个有效方法是正确设置 React Hook 的依赖项。或者，对于过时的状态，使用函数方式更新状态。\u003c/p\u003e\n\u003cp\u003e你认为闭包使得 React Hook 很难理解吗？\u003c/p\u003e\n\u003ch2\u003e来源\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e作者：Dmitri Pavlutin\u003cbr\u003e\n译者：前端小智\u003cbr\u003e\n来源：dmitripavlutin\u003cbr\u003e\n原文： \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F\"\u003ehttps://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/body\u003e\u003c/html\u003e\n  "])</script><script>self.__next_f.push([1,"c:[\"$\",\"div\",null,{\"className\":\"article_pageBody__Bryg4\",\"children\":[[\"$\",\"$Le\",null,{\"menuItemList\":[{\"id\":0,\"label\":\"首页\",\"href\":\"/\",\"icon\":\"/icons/home_gray.svg\",\"iconSelected\":\"/icons/home_black.svg\"},{\"id\":1,\"label\":\"文章\",\"href\":\"/articles/all/1\",\"icon\":\"/icons/article_gray.svg\",\"iconSelected\":\"/icons/article_black.svg\"},{\"id\":3,\"label\":\"关于\",\"href\":\"/about\",\"icon\":\"/icons/about_gray.svg\",\"iconSelected\":\"/icons/about_black.svg\"},{\"id\":4,\"label\":\"搜索\",\"href\":\"/search\",\"icon\":\"/icons/search_gray.svg\",\"iconSelected\":\"/icons/search_black.svg\"}],\"currentSelectedLabel\":\"文章\"}],[\"$\",\"div\",null,{\"className\":\"article_pageBodyMain___x_AF\",\"children\":[[\"$\",\"$Lf\",null,{}],[\"$\",\"div\",null,{\"className\":\"article_articleContainer__uRwUh scrollContent\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article_articleBody__0coIY scrollContent\",\"children\":[[\"$\",\"h1\",null,{\"style\":{\"marginBottom\":\"0.1rem\",\"marginTop\":\"0.2rem\"},\"children\":\"使用js和React Hook时的过时闭包问题及解决方案\"}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"tags_tags__qM_Ja\",\"children\":[[\"$\",\"p\",null,{\"className\":\"tags_label__Rg6b2\",\"children\":\"分类\"}],[[\"$\",\"$L10\",\"0\",{\"href\":\"/articles/新知笔记/1\",\"children\":[\"$\",\"p\",\"0\",{\"className\":\"tags_tag__HZYxk tags_tagLink__gnw9V\",\"children\":\"新知笔记\"}]}],[\"$\",\"$L10\",\"1\",{\"href\":\"/articles/前端技术/1\",\"children\":[\"$\",\"p\",\"1\",{\"className\":\"tags_tag__HZYxk tags_tagLink__gnw9V\",\"children\":\"前端技术\"}]}]],false]}],[\"$\",\"div\",null,{\"className\":\"tags_tags__qM_Ja\",\"children\":[[\"$\",\"p\",null,{\"className\":\"tags_label__Rg6b2\",\"children\":\"标签\"}],\"$undefined\",[[\"$\",\"p\",\"0\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"javascript\"}],[\"$\",\"p\",\"1\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"React\"}],[\"$\",\"p\",\"2\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"过时闭包\"}],[\"$\",\"p\",\"3\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"Hook\"}],[\"$\",\"p\",\"4\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"解决方案\"}]]]}],[\"$\",\"$L11\",null,{\"path\":\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"serverURL\":\"https://remark.timeshike.com/\"}]]}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$12\"}}],[\"$\",\"$L13\",null,{}],[\"$\",\"$L14\",null,{\"path\":\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"serverURL\":\"https://remark.timeshike.com/\",\"lang\":\"zh-CN\"}],[\"$\",\"div\",null,{\"className\":\"bottomBar_bottomBar__uHU1W\",\"children\":[\"$\",\"div\",null,{\"className\":\"bottomBar_text__iz3cM\",\"children\":[\"Powerd by\",[\"$\",\"a\",null,{\"href\":\"https://github.com/hixyl/YlBlog\",\"target\":\"_blank\",\"children\":\" YlBlog(玉龙博客)\"}]]}]}]]}],[\"$\",\"$L15\",null,{}]]}]]}],[\"$\",\"$L16\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"7:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"使用js和React Hook时的过时闭包问题及解决方案 - 流年石刻\"}],[\"$\",\"meta\",\"2\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"3\",{\"name\":\"next-size-adjust\"}]]\n"])</script></body></html>