<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/aae87c042353adfd.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/99f6a99e5e57ec87.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/d0df4e9d9cd28850.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/c033a265c4b6e7f8.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/81abeb1d965206f7.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/a46a6036119d7d12.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/51cbc18a5b192d8f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-33ea8a143bfabde9.js"/><script src="/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/_next/static/chunks/23-020bd7ae6b960732.js" async=""></script><script src="/_next/static/chunks/main-app-aeb5213bc864b27a.js" async=""></script><script src="/_next/static/chunks/app/layout-950680b5068c0831.js" async=""></script><script src="/_next/static/chunks/221e729c-e5a67d23aac7644c.js" async=""></script><script src="/_next/static/chunks/9316e0b3-81def07e0919db1c.js" async=""></script><script src="/_next/static/chunks/974-9ffea8f9ea4bfaa2.js" async=""></script><script src="/_next/static/chunks/536-12c341f043d96047.js" async=""></script><script src="/_next/static/chunks/665-f7c57b2084cbed6b.js" async=""></script><script src="/_next/static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-N3DJ3JTVT2" as="script"/><link rel="icon" href="/favicon.png?&lt;generated&gt;" type="image/&lt;generated&gt;" sizes="&lt;generated&gt;"/><title>使用js和React Hook时的过时闭包问题及解决方案 - 流年石刻</title><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_36bd41"><div class="article_pageBody__Bryg4"><div class="header_header__us6ao"><div class="header_topHeader__xNJQ1"><a href="/"><div class="header_logo__IbzcJ">流年石刻</div></a><div class="menu_menuBox__ZCxZE"><a href="/"><p style="--icon-unSelected:url(/icons/home_gray.svg);--icon-selected:url(/icons/home_black.svg)" class="menu_navListItem__znGi9">首页</p></a><a href="/articles/all/1/"><p style="--icon-unSelected:url(/icons/article_gray.svg);--icon-selected:url(/icons/article_black.svg)" class="menu_navListItemSelected__JZBTq">文章</p></a><a href="/about/"><p style="--icon-unSelected:url(/icons/about_gray.svg);--icon-selected:url(/icons/about_black.svg)" class="menu_navListItem__znGi9">关于</p></a><a href="/search/"><p style="--icon-unSelected:url(/icons/search_gray.svg);--icon-selected:url(/icons/search_black.svg)" class="menu_navListItem__znGi9">搜索</p></a></div><div class="header_iconArea__Co05n"><img alt="menu" loading="lazy" width="30" height="30" decoding="async" data-nimg="1" class="header_menuIcon__7dQN0" style="color:transparent" src="/_next/static/media/menu.c309d6d5.svg"/></div></div><div class="mobileMenu_mobileMenu__Mz_1e mobileMenu_menuContainer__hndoP "><a href="/"><div style="--icon-unSelected:url(/icons/home_gray.svg);--icon-selected:url(/icons/home_black.svg)" class="mobileMenu_item__pY1st ">首页</div></a><a href="/articles/all/1/"><div style="--icon-unSelected:url(/icons/article_gray.svg);--icon-selected:url(/icons/article_black.svg)" class="mobileMenu_item__pY1st mobileMenu_itemSelected__d5YAL">文章</div></a><a href="/about/"><div style="--icon-unSelected:url(/icons/about_gray.svg);--icon-selected:url(/icons/about_black.svg)" class="mobileMenu_item__pY1st ">关于</div></a><a href="/search/"><div style="--icon-unSelected:url(/icons/search_gray.svg);--icon-selected:url(/icons/search_black.svg)" class="mobileMenu_item__pY1st ">搜索</div></a></div></div><div class="article_pageBodyMain___x_AF"><div class="sidebar_sidebar__6HDFv sidebar_open__ia_Zv"><div class="sidebar_sidebarInner__NiyBR"><div class="topImgBox_topImgBox__2OSEr"><img alt="" loading="lazy" width="1024" height="1024" decoding="async" data-nimg="1" class="topImgBox_topImg__6hmTH" style="color:transparent" src="/_next/static/media/author.2cacf696.jpg"/><div class="topImgBox_textArea__iSnnz"><div class="topImgBox_author__URTnh">星玉龙</div><div class="topImgBox_position__7qz_f">前端工程师</div><a class="topImgBox_email__skkTy" href="mailto:me@timeshike.com">me@timeshike.com</a><a class="topImgBox_githubBtn__YYbAh" href="https://github.com/hixyl">Github</a><div class="topImgBox_content__lmDiZ">闲云潭影，物换星移<br/>滕王高阁，几度春秋<br/>故人不在，长江空流<br/>月圆复缺，岁月悠悠<br/></div><div class="topImgBox_bottomBtns__EIkFU"><a href="/atom.xml"><img alt="rss" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/rss.d066fc0f.svg"/></a></div></div></div></div><div class="sidebar_btnArea__Wtf3d"><div class="sidebar_btnRect__RQ7s5"><img alt="rightArray" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="sidebar_imgBtn__gmp3y" style="color:transparent" src="/_next/static/media/left_array.0dce0964.svg"/></div></div></div><div class="article_articleContainer__uRwUh scrollContent"><div class="article_articleBody__0coIY scrollContent"><h1 style="margin-bottom:0.1rem;margin-top:0.2rem">使用js和React Hook时的过时闭包问题及解决方案</h1><div><div class="tags_tags__qM_Ja"><p class="tags_label__Rg6b2">分类</p><a href="/articles/新知笔记/1/"><p class="tags_tag__HZYxk tags_tagLink__gnw9V">新知笔记</p></a><a href="/articles/前端技术/1/"><p class="tags_tag__HZYxk tags_tagLink__gnw9V">前端技术</p></a></div><div class="tags_tags__qM_Ja"><p class="tags_label__Rg6b2">标签</p><p class="tags_tag__HZYxk ">javascript</p><p class="tags_tag__HZYxk ">React</p><p class="tags_tag__HZYxk ">过时闭包</p><p class="tags_tag__HZYxk ">Hook</p><p class="tags_tag__HZYxk ">解决方案</p></div><div class="walinePageView_walinePageview__C8Aml"><img alt="" loading="lazy" width="25" height="25" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/eye.7eadf26d.svg"/><span style="font-size:0.9rem;color:gray" class="waline-pageview-count"></span></div></div><article>
    <p class="time">发布时间：<time datetime="20 October, 2023">2023-10-20 16:40:29</time></p>
    <p class="words">本文字数：1,764 字       阅读完需：约 4 分钟</p>
    <h2>1. JS 中的闭包</h2>
<p>下面定义了一个工厂函数 <code>createIncrement(i)</code>，它返回一个<code>increment</code>函数。之后，每次调用<code>increment</code>函数时，内部计数器的值都会增加<code>i</code>。</p>
<pre><code class="language-javascript">function createIncrement(i) {
  let value = 0;
  function increment() {
    value += i;
    console.log(value);
  }
  return increment;
}

const inc = createIncrement(1);
inc(); // 1
inc(); // 2
</code></pre>
<p><code>createIncrement(1)</code> 返回一个增量函数，该函数赋值给<code>inc</code>变量。当调用<code>inc()</code>时，<code>value</code> 变量加<code>1</code>。</p>
<p>第一次调用<code>inc()</code>返回<code>1</code>，第二次调用返回<code>2</code>，依此类推。</p>
<p>这挺趣的，只要调用<code>inc()</code>还不带参数，JS 仍然知道当前 <code>value</code> 和 <code>i</code> 的增量，来看看这玩意是如何工作的。</p>
<p>原理就在 <code>createIncrement()</code> 中。当在函数上返回一个函数时，有会有闭包产生。闭包捕获词法作用域中的变量 <code>value</code> 和 <code>i</code>。</p>
<p>词法作用域是定义闭包的外部作用域。在本例中，<code>increment()</code> 的词法作用域是<code>createIncrement()</code>的作用域，其中包含变量 <code>value</code> 和 <code>i</code>。</p>
<p><img src="guoshibibao1.png" alt=""></p>
<p>无论在何处调用 <code>inc()</code>，甚至在 <code>createIncrement()</code> 的作用域之外，它都可以访问 <code>value</code> 和 <code>i</code>。</p>
<blockquote>
<p>闭包是一个可以从其词法作用域记住和修改变量的函数，不管执行作用域是什么。</p>
</blockquote>
<p>继续这个例子，可以在任何地方调用 <code>inc()</code>，甚至在异步回调中也可以:</p>
<pre><code class="language-javascript">(function() {
  inc(); // 3
}());

setTimeout(function() {
  inc(); // 4
}, 1000);
</code></pre>
<h2>2. React Hooks 中的闭包</h2>
<p>通过简化状态重用和副作用管理，Hooks 取代了基于类的组件。此外，咱们可以将重复的逻辑提取到自定义 Hook 中，以便在应用程序之间重用。</p>
<p>Hooks 严重依赖于 JS 闭包,但是闭包有时很棘手。</p>
<p>当咱们使用一个有多种副作用和状态管理的 React 组件时，可能会遇到的一个问题是过时的闭包，这可能很难解决。</p>
<p>咱们从提炼出过时的闭包开始。然后，看看过时的闭包如何影响 React Hook，以及如何解决这个问题。</p>
<h2>3. 过时的闭包</h2>
<p>工厂函数<code>createIncrement(i)</code>返回一个<code>increment</code>函数。<code>increment</code> 函数对 <code>value</code> 增加i<code>请输入代码</code> ，并返回一个记录当前 <code>value</code> 的函数</p>
<pre><code class="language-javascript">function createIncrement(i) {
  let value = 0;
  function increment() {
    value += i;
    console.log(value);
    const message = `Current value is ${value}`;
    return function logValue() {
      console.log(message);
    };
  }
  
  return increment;
}

const inc = createIncrement(1);
const log = inc(); // 打印 1
inc();             // 打印 2
inc();             // 打印 3
// 无法正确工作
log();             // 打印 "Current value is 1"
</code></pre>
<p>在第一次调用<code>inc()</code>时，返回的闭包被分配给变量 <code>log</code>。对 <code>inc()</code> 的 <code>3</code> 次调用的增量 <code>value</code> 为 <code>3</code>。</p>
<p>最后，调用<code>log()</code> 打印 message <code>“Current value is 1”</code>，这是出乎意料的，因为此时 <code>value</code> 等于 <code>3</code>。</p>
<p><code>log()</code>是过时的闭包。在第一次调用 <code>inc()</code> 时，闭包 <code>log()</code> 捕获了具有 <code>“Current value is 1”</code> 的 <code>message</code> 变量。而现在，当 <code>value</code> 已经是 <code>3</code> 时，<code>message</code> 变量已经过时了。</p>
<blockquote>
<p>过时的闭包捕获具有过时值的变量。</p>
</blockquote>
<h2>4.修复过时闭包的问题</h2>
<h4>使用新的闭包</h4>
<p>解决过时闭包的第一种方法是找到捕获最新变量的闭包。</p>
<p>咱们找到捕获了最新 <code>message</code> 变量的闭包。就是从最后一次调用 inc() 返回的闭包。</p>
<pre><code class="language-javascript">const inc = createIncrement(1);

inc();  // 打印 1
inc();  // 打印 2
const latestLog = inc(); // 打印 3
// 正常工作
latestLog(); // 打印 "Current value is 3"
</code></pre>
<p><code>latestLog</code> 捕获的 <code>message</code> 变量具有最新的的值 “Current value is 3”。</p>
<p>顺便说一下，这大概就是 React Hook 处理闭包新鲜度的方式。</p>
<p>Hooks 实现假设在组件重新渲染之间，作为 Hook 回调提供的最新闭包(例如 <code>useEffect(callback)</code>) 已经从组件的函数作用域捕获了最新的变量。</p>
<h4>关闭已更改的变量</h4>
<p>第二种方法是让<code>logValue()</code>直接使用 <code>value</code>。</p>
<p>让我们移动行 <code>const message = ...;</code> 到 <code>logValue()</code> 函数体中：</p>
<pre><code class="language-javascript">function createIncrementFixed(i) {
  let value = 0;
  function increment() {
    value += i;
    console.log(value);
    return function logValue() {
      const message = `Current value is ${value}`;
      console.log(message);
    };
  }
  
  return increment;
}

const inc = createIncrementFixed(1);
const log = inc(); // 打印 1
inc();             // 打印 2
inc();             // 打印 3
// 正常工作
log();             // 打印 "Current value is 3"
</code></pre>
<p><code>logValue()</code> 关闭 <code>createIncrementFixed()</code> 作用域内的 <code>value</code> 变量。<code>log()</code> 现在打印正确的消息“<code>Current value is 3</code>”。</p>
<h2>5. Hook 中过时的闭包</h2>
<h4>useEffect()</h4>
<p>现在来研究一下在使用 <code>useEffect()</code> Hook 时出现过时闭包的常见情况。</p>
<p>在组件 <code>&#x3C;WatchCount></code> 中，<code>useEffect()</code>每秒打印 <code>count</code> 的值。</p>
<pre><code class="language-javascript">function WatchCount() {
  const [count, setCount] = useState(0);

  useEffect(function() {
    setInterval(function log() {
      console.log(`Count is: ${count}`);
    }, 2000);
  }, []);

  return (
    &#x3C;div>
      {count}
      &#x3C;button onClick={() => setCount(count + 1) }>
        加1
      &#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<p>打开 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-broken-2-gyhzk">CodeSandbox</a> 并单击几次<strong>加1</strong>按钮。然后看看控制台，每2秒打印 <code>Count is: 0</code>。</p>
<p>咋这样呢？</p>
<p>在第一次渲染时，<code>log()</code> 中闭包捕获 <code>count</code> 变量的值 <code>0</code>。过后，即使 <code>count</code> 增加，<code>log()</code>中使用的仍然是初始化的值 <code>0</code>。<code>log()</code> 中的闭包是一个过时的闭包。</p>
<p>解决方案是让 <code>useEffect()</code>知道 <code>log()</code> 中的闭包依赖于<code>count</code>：</p>
<pre><code class="language-javascript">function WatchCount() {
  const [count, setCount] = useState(0);

  useEffect(function() {
    const id = setInterval(function log() {
      console.log(`Count is: ${count}`);
    }, 2000);
    return function() {
      clearInterval(id);
    }
  }, [count]); // 看这里，这行是重点

  return (
    &#x3C;div>
      {count}
      &#x3C;button onClick={() => setCount(count + 1) }>
        Increase
      &#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<p>适当地设置依赖项后，一旦 <code>count</code> 更改，<code>useEffect()</code> 就更新闭包。</p>
<p>同样打开修复的 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-fixed-2-ybv47">codesandbox</a>，单击几次<strong>加1</strong>按钮。然后看看控制台，这次打印就是正确的值了。</p>
<p>正确管理 Hook 依赖关系是解决过时闭包问题的关键。推荐安装 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react-hooks">eslint-plugin-react-hooks</a>,它可以帮助咱们检测被遗忘的依赖项。</p>
<h4>useState()</h4>
<p>组件<code>&#x3C;DelayedCount></code>有 2 个按钮：</p>
<ul>
<li>点击按键 <strong>“Increase async”</strong> 在异步模式下以<code>1</code>秒的延迟递增计数器</li>
</ul>
<pre><code class="language-js"> 在同步模式下，点击按键 “Increase sync” 会立即增加计数器。
 function DelayedCount() {
  const [count, setCount] = useState(0);
 function handleClickAsync() {
 setTimeout(function delay() {   setCount(count + 1); }, 1000);
 }
 function handleClickSync() {
 setCount(count + 1);
 }
 return (
 &#x3C;div>   {count}   &#x3C;button onClick={handleClickAsync}>Increase async&#x3C;/button>   &#x3C;button onClick={handleClickSync}>Increase sync&#x3C;/button> &#x3C;/div>
 );
}
 
</code></pre>
<p>现在<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fuse-state-broken-0q994">打开 codesandbox 演示</a>。点击 <strong>“Increase async”</strong> 按键然后立即点击 <strong>“Increase sync”</strong> 按钮，<code>count</code> 只更新到 <code>1</code>。</p>
<p>这是因为 <code>delay()</code> 是一个过时的闭包。</p>
<p>来看看这个过程发生了什么：</p>
<ol>
<li>初始渲染：<code>count</code> 值为 <code>0</code>。</li>
<li>点击 <strong>'Increase async'</strong> 按钮。<code>delay()</code> 闭包捕获 <code>count</code> 的值 <code>0</code>。<code>setTimeout()</code> 1 秒后调用 <code>delay()</code>。</li>
<li>点击 <strong>“Increase async”</strong> 按键。<code>handleClickSync()</code> 调用 <code>setCount(0 + 1)</code> 将 <code>count</code> 的值设置为 <code>1</code>，组件重新渲染。</li>
<li><code>1</code> 秒之后，<code>setTimeout()</code> 执行 <code>delay()</code> 函数。但是 <code>delay()</code> 中闭包保存 <code>count</code> 的值是初始渲染的值 <code>0</code>，所以调用 <code>setState(0 + 1)</code>，结果<code>count</code>保持为 <code>1</code>。</li>
</ol>
<p><code>delay()</code> 是一个过时的闭包，它使用在初始渲染期间捕获的过时的 <code>count</code> 变量。</p>
<p>为了解决这个问题，可以使用函数方法来更新 <code>count</code> 状态：</p>
<pre><code class="language-javascript">function DelayedCount() {
  const [count, setCount] = useState(0);

  function handleClickAsync() {
    setTimeout(function delay() {
      setCount(count => count + 1); // 这行是重点
    }, 1000);
  }

  function handleClickSync() {
    setCount(count + 1);
  }

  return (
    &#x3C;div>
      {count}
      &#x3C;button onClick={handleClickAsync}>Increase async&#x3C;/button>
      &#x3C;button onClick={handleClickSync}>Increase sync&#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<p>现在 <code>setCount(count => count + 1)</code> 更新了 <code>delay()</code> 中的 <code>count</code> 状态。React 确保将最新状态值作为参数提供给更新状态函数，过时的闭包的问题就解决了。</p>
<h2>总结</h2>
<p>闭包是一个函数，它从定义变量的地方(或其词法范围)捕获变量。闭包是每个 JS 开发人员都应该知道的一个重要概念。</p>
<p>当闭包捕获过时的变量时，就会出现过时闭包的问题。解决过时闭包的一个有效方法是正确设置 React Hook 的依赖项。或者，对于过时的状态，使用函数方式更新状态。</p>
<p>你认为闭包使得 React Hook 很难理解吗？</p>
<h2>来源</h2>
<blockquote>
<p>作者：Dmitri Pavlutin<br>
译者：前端小智<br>
来源：dmitripavlutin<br>
原文： <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F">https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F</a></p>
</blockquote>

  </article><div class="Toastify"></div><div></div><div class="bottomBar_bottomBar__uHU1W"><div class="bottomBar_text__iz3cM">Powerd by<a href="https://github.com/hixyl/YlBlog" target="_blank"> YlBlog(玉龙博客)</a></div></div></div></div></div></div><script src="/_next/static/chunks/webpack-33ea8a143bfabde9.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/a34f9d1faa5f3315-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/aae87c042353adfd.css\",\"style\"]\n3:HL[\"/_next/static/css/99f6a99e5e57ec87.css\",\"style\"]\n4:HL[\"/_next/static/css/d0df4e9d9cd28850.css\",\"style\"]\n5:HL[\"/_next/static/css/c033a265c4b6e7f8.css\",\"style\"]\n6:HL[\"/_next/static/css/81abeb1d965206f7.css\",\"style\"]\n7:HL[\"/_next/static/css/a46a6036119d7d12.css\",\"style\"]\n8:HL[\"/_next/static/css/51cbc18a5b192d8f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"9:I[5751,[],\"\"]\nc:I[9275,[],\"\"]\ne:I[1343,[],\"\"]\nf:I[4080,[\"185\",\"static/chunks/app/layout-950680b5068c0831.js\"],\"\"]\n10:I[4266,[\"185\",\"static/chunks/app/layout-950680b5068c0831.js\"],\"default\"]\n12:I[6130,[],\"\"]\nd:[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"]\n13:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/aae87c042353adfd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L9\",null,{\"buildId\":\"bbFeRMIduFcZud7BNs8NQ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/article/%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/\",\"initialTree\":[\"\",{\"children\":[\"article\",{\"children\":[[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"],{\"children\":[\"__PAGE__?{\\\"id\\\":\\\"使用js和React-Hook时的过时闭包问题及解决方案\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"article\",{\"children\":[[\"id\",\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$La\",\"$Lb\"],null],null]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"article\",\"children\",\"$d\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/99f6a99e5e57ec87.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d0df4e9d9cd28850.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c033a265c4b6e7f8.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/81abeb1d965206f7.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a46a6036119d7d12.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/51cbc18a5b192d8f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"article\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"zh\",\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png?\u003cgenerated\u003e\",\"type\":\"image/\u003cgenerated\u003e\",\"sizes\":\"\u003cgenerated\u003e\"}],[\"$\",\"$Lf\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-N3DJ3JTVT2\"}],[\"$\",\"$Lf\",null,{\"id\":\"google-analytics\",\"children\":\"\\n          window.dataLayer = window.dataLayer || [];\\n          function gtag(){dataLayer.push(arguments);}\\n          gtag('js', new Date());\\n        \\n          gtag('config', 'G-N3DJ3JTVT2');\\n        \"}],[\"$\",\"body\",null,{\"className\":\"__className_36bd41\",\"children\":[[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],[\"$\",\"$L10\",null,{}]]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L11\"],\"globalErrorComponent\":\"$12\",\"missingSlots\":\"$W13\"}]]\n"])</script><script>self.__next_f.push([1,"14:I[2612,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n15:I[4306,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n16:I[231,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"\"]\n17:I[4254,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n19:I[3869,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n1a:I[5339,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"Waline\"]\n1b:I[8360,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"st"])</script><script>self.__next_f.push([1,"atic/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n1c:I[4226,[\"577\",\"static/chunks/221e729c-e5a67d23aac7644c.js\",\"231\",\"static/chunks/9316e0b3-81def07e0919db1c.js\",\"974\",\"static/chunks/974-9ffea8f9ea4bfaa2.js\",\"536\",\"static/chunks/536-12c341f043d96047.js\",\"665\",\"static/chunks/665-f7c57b2084cbed6b.js\",\"241\",\"static/chunks/app/article/%5Bid%5D/page-28a3798f9eb189fc.js\"],\"default\"]\n18:T31c3,"])</script><script>self.__next_f.push([1,"\n    \u003cp class=\"time\"\u003e发布时间：\u003ctime datetime=\"20 October, 2023\"\u003e2023-10-20 16:40:29\u003c/time\u003e\u003c/p\u003e\n    \u003cp class=\"words\"\u003e本文字数：1,764 字       阅读完需：约 4 分钟\u003c/p\u003e\n    \u003ch2\u003e1. JS 中的闭包\u003c/h2\u003e\n\u003cp\u003e下面定义了一个工厂函数 \u003ccode\u003ecreateIncrement(i)\u003c/code\u003e，它返回一个\u003ccode\u003eincrement\u003c/code\u003e函数。之后，每次调用\u003ccode\u003eincrement\u003c/code\u003e函数时，内部计数器的值都会增加\u003ccode\u003ei\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction createIncrement(i) {\n  let value = 0;\n  function increment() {\n    value += i;\n    console.log(value);\n  }\n  return increment;\n}\n\nconst inc = createIncrement(1);\ninc(); // 1\ninc(); // 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecreateIncrement(1)\u003c/code\u003e 返回一个增量函数，该函数赋值给\u003ccode\u003einc\u003c/code\u003e变量。当调用\u003ccode\u003einc()\u003c/code\u003e时，\u003ccode\u003evalue\u003c/code\u003e 变量加\u003ccode\u003e1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e第一次调用\u003ccode\u003einc()\u003c/code\u003e返回\u003ccode\u003e1\u003c/code\u003e，第二次调用返回\u003ccode\u003e2\u003c/code\u003e，依此类推。\u003c/p\u003e\n\u003cp\u003e这挺趣的，只要调用\u003ccode\u003einc()\u003c/code\u003e还不带参数，JS 仍然知道当前 \u003ccode\u003evalue\u003c/code\u003e 和 \u003ccode\u003ei\u003c/code\u003e 的增量，来看看这玩意是如何工作的。\u003c/p\u003e\n\u003cp\u003e原理就在 \u003ccode\u003ecreateIncrement()\u003c/code\u003e 中。当在函数上返回一个函数时，有会有闭包产生。闭包捕获词法作用域中的变量 \u003ccode\u003evalue\u003c/code\u003e 和 \u003ccode\u003ei\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e词法作用域是定义闭包的外部作用域。在本例中，\u003ccode\u003eincrement()\u003c/code\u003e 的词法作用域是\u003ccode\u003ecreateIncrement()\u003c/code\u003e的作用域，其中包含变量 \u003ccode\u003evalue\u003c/code\u003e 和 \u003ccode\u003ei\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"guoshibibao1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e无论在何处调用 \u003ccode\u003einc()\u003c/code\u003e，甚至在 \u003ccode\u003ecreateIncrement()\u003c/code\u003e 的作用域之外，它都可以访问 \u003ccode\u003evalue\u003c/code\u003e 和 \u003ccode\u003ei\u003c/code\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e闭包是一个可以从其词法作用域记住和修改变量的函数，不管执行作用域是什么。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e继续这个例子，可以在任何地方调用 \u003ccode\u003einc()\u003c/code\u003e，甚至在异步回调中也可以:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e(function() {\n  inc(); // 3\n}());\n\nsetTimeout(function() {\n  inc(); // 4\n}, 1000);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. React Hooks 中的闭包\u003c/h2\u003e\n\u003cp\u003e通过简化状态重用和副作用管理，Hooks 取代了基于类的组件。此外，咱们可以将重复的逻辑提取到自定义 Hook 中，以便在应用程序之间重用。\u003c/p\u003e\n\u003cp\u003eHooks 严重依赖于 JS 闭包,但是闭包有时很棘手。\u003c/p\u003e\n\u003cp\u003e当咱们使用一个有多种副作用和状态管理的 React 组件时，可能会遇到的一个问题是过时的闭包，这可能很难解决。\u003c/p\u003e\n\u003cp\u003e咱们从提炼出过时的闭包开始。然后，看看过时的闭包如何影响 React Hook，以及如何解决这个问题。\u003c/p\u003e\n\u003ch2\u003e3. 过时的闭包\u003c/h2\u003e\n\u003cp\u003e工厂函数\u003ccode\u003ecreateIncrement(i)\u003c/code\u003e返回一个\u003ccode\u003eincrement\u003c/code\u003e函数。\u003ccode\u003eincrement\u003c/code\u003e 函数对 \u003ccode\u003evalue\u003c/code\u003e 增加i\u003ccode\u003e请输入代码\u003c/code\u003e ，并返回一个记录当前 \u003ccode\u003evalue\u003c/code\u003e 的函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction createIncrement(i) {\n  let value = 0;\n  function increment() {\n    value += i;\n    console.log(value);\n    const message = `Current value is ${value}`;\n    return function logValue() {\n      console.log(message);\n    };\n  }\n  \n  return increment;\n}\n\nconst inc = createIncrement(1);\nconst log = inc(); // 打印 1\ninc();             // 打印 2\ninc();             // 打印 3\n// 无法正确工作\nlog();             // 打印 \"Current value is 1\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在第一次调用\u003ccode\u003einc()\u003c/code\u003e时，返回的闭包被分配给变量 \u003ccode\u003elog\u003c/code\u003e。对 \u003ccode\u003einc()\u003c/code\u003e 的 \u003ccode\u003e3\u003c/code\u003e 次调用的增量 \u003ccode\u003evalue\u003c/code\u003e 为 \u003ccode\u003e3\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e最后，调用\u003ccode\u003elog()\u003c/code\u003e 打印 message \u003ccode\u003e“Current value is 1”\u003c/code\u003e，这是出乎意料的，因为此时 \u003ccode\u003evalue\u003c/code\u003e 等于 \u003ccode\u003e3\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elog()\u003c/code\u003e是过时的闭包。在第一次调用 \u003ccode\u003einc()\u003c/code\u003e 时，闭包 \u003ccode\u003elog()\u003c/code\u003e 捕获了具有 \u003ccode\u003e“Current value is 1”\u003c/code\u003e 的 \u003ccode\u003emessage\u003c/code\u003e 变量。而现在，当 \u003ccode\u003evalue\u003c/code\u003e 已经是 \u003ccode\u003e3\u003c/code\u003e 时，\u003ccode\u003emessage\u003c/code\u003e 变量已经过时了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e过时的闭包捕获具有过时值的变量。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e4.修复过时闭包的问题\u003c/h2\u003e\n\u003ch4\u003e使用新的闭包\u003c/h4\u003e\n\u003cp\u003e解决过时闭包的第一种方法是找到捕获最新变量的闭包。\u003c/p\u003e\n\u003cp\u003e咱们找到捕获了最新 \u003ccode\u003emessage\u003c/code\u003e 变量的闭包。就是从最后一次调用 inc() 返回的闭包。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst inc = createIncrement(1);\n\ninc();  // 打印 1\ninc();  // 打印 2\nconst latestLog = inc(); // 打印 3\n// 正常工作\nlatestLog(); // 打印 \"Current value is 3\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elatestLog\u003c/code\u003e 捕获的 \u003ccode\u003emessage\u003c/code\u003e 变量具有最新的的值 “Current value is 3”。\u003c/p\u003e\n\u003cp\u003e顺便说一下，这大概就是 React Hook 处理闭包新鲜度的方式。\u003c/p\u003e\n\u003cp\u003eHooks 实现假设在组件重新渲染之间，作为 Hook 回调提供的最新闭包(例如 \u003ccode\u003euseEffect(callback)\u003c/code\u003e) 已经从组件的函数作用域捕获了最新的变量。\u003c/p\u003e\n\u003ch4\u003e关闭已更改的变量\u003c/h4\u003e\n\u003cp\u003e第二种方法是让\u003ccode\u003elogValue()\u003c/code\u003e直接使用 \u003ccode\u003evalue\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e让我们移动行 \u003ccode\u003econst message = ...;\u003c/code\u003e 到 \u003ccode\u003elogValue()\u003c/code\u003e 函数体中：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction createIncrementFixed(i) {\n  let value = 0;\n  function increment() {\n    value += i;\n    console.log(value);\n    return function logValue() {\n      const message = `Current value is ${value}`;\n      console.log(message);\n    };\n  }\n  \n  return increment;\n}\n\nconst inc = createIncrementFixed(1);\nconst log = inc(); // 打印 1\ninc();             // 打印 2\ninc();             // 打印 3\n// 正常工作\nlog();             // 打印 \"Current value is 3\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elogValue()\u003c/code\u003e 关闭 \u003ccode\u003ecreateIncrementFixed()\u003c/code\u003e 作用域内的 \u003ccode\u003evalue\u003c/code\u003e 变量。\u003ccode\u003elog()\u003c/code\u003e 现在打印正确的消息“\u003ccode\u003eCurrent value is 3\u003c/code\u003e”。\u003c/p\u003e\n\u003ch2\u003e5. Hook 中过时的闭包\u003c/h2\u003e\n\u003ch4\u003euseEffect()\u003c/h4\u003e\n\u003cp\u003e现在来研究一下在使用 \u003ccode\u003euseEffect()\u003c/code\u003e Hook 时出现过时闭包的常见情况。\u003c/p\u003e\n\u003cp\u003e在组件 \u003ccode\u003e\u0026#x3C;WatchCount\u003e\u003c/code\u003e 中，\u003ccode\u003euseEffect()\u003c/code\u003e每秒打印 \u003ccode\u003ecount\u003c/code\u003e 的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction WatchCount() {\n  const [count, setCount] = useState(0);\n\n  useEffect(function() {\n    setInterval(function log() {\n      console.log(`Count is: ${count}`);\n    }, 2000);\n  }, []);\n\n  return (\n    \u0026#x3C;div\u003e\n      {count}\n      \u0026#x3C;button onClick={() =\u003e setCount(count + 1) }\u003e\n        加1\n      \u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打开 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-broken-2-gyhzk\"\u003eCodeSandbox\u003c/a\u003e 并单击几次\u003cstrong\u003e加1\u003c/strong\u003e按钮。然后看看控制台，每2秒打印 \u003ccode\u003eCount is: 0\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e咋这样呢？\u003c/p\u003e\n\u003cp\u003e在第一次渲染时，\u003ccode\u003elog()\u003c/code\u003e 中闭包捕获 \u003ccode\u003ecount\u003c/code\u003e 变量的值 \u003ccode\u003e0\u003c/code\u003e。过后，即使 \u003ccode\u003ecount\u003c/code\u003e 增加，\u003ccode\u003elog()\u003c/code\u003e中使用的仍然是初始化的值 \u003ccode\u003e0\u003c/code\u003e。\u003ccode\u003elog()\u003c/code\u003e 中的闭包是一个过时的闭包。\u003c/p\u003e\n\u003cp\u003e解决方案是让 \u003ccode\u003euseEffect()\u003c/code\u003e知道 \u003ccode\u003elog()\u003c/code\u003e 中的闭包依赖于\u003ccode\u003ecount\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction WatchCount() {\n  const [count, setCount] = useState(0);\n\n  useEffect(function() {\n    const id = setInterval(function log() {\n      console.log(`Count is: ${count}`);\n    }, 2000);\n    return function() {\n      clearInterval(id);\n    }\n  }, [count]); // 看这里，这行是重点\n\n  return (\n    \u0026#x3C;div\u003e\n      {count}\n      \u0026#x3C;button onClick={() =\u003e setCount(count + 1) }\u003e\n        Increase\n      \u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e适当地设置依赖项后，一旦 \u003ccode\u003ecount\u003c/code\u003e 更改，\u003ccode\u003euseEffect()\u003c/code\u003e 就更新闭包。\u003c/p\u003e\n\u003cp\u003e同样打开修复的 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstale-closure-use-effect-fixed-2-ybv47\"\u003ecodesandbox\u003c/a\u003e，单击几次\u003cstrong\u003e加1\u003c/strong\u003e按钮。然后看看控制台，这次打印就是正确的值了。\u003c/p\u003e\n\u003cp\u003e正确管理 Hook 依赖关系是解决过时闭包问题的关键。推荐安装 \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react-hooks\"\u003eeslint-plugin-react-hooks\u003c/a\u003e,它可以帮助咱们检测被遗忘的依赖项。\u003c/p\u003e\n\u003ch4\u003euseState()\u003c/h4\u003e\n\u003cp\u003e组件\u003ccode\u003e\u0026#x3C;DelayedCount\u003e\u003c/code\u003e有 2 个按钮：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e点击按键 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 在异步模式下以\u003ccode\u003e1\u003c/code\u003e秒的延迟递增计数器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e 在同步模式下，点击按键 “Increase sync” 会立即增加计数器。\n function DelayedCount() {\n  const [count, setCount] = useState(0);\n function handleClickAsync() {\n setTimeout(function delay() {   setCount(count + 1); }, 1000);\n }\n function handleClickSync() {\n setCount(count + 1);\n }\n return (\n \u0026#x3C;div\u003e   {count}   \u0026#x3C;button onClick={handleClickAsync}\u003eIncrease async\u0026#x3C;/button\u003e   \u0026#x3C;button onClick={handleClickSync}\u003eIncrease sync\u0026#x3C;/button\u003e \u0026#x3C;/div\u003e\n );\n}\n \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在\u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fuse-state-broken-0q994\"\u003e打开 codesandbox 演示\u003c/a\u003e。点击 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 按键然后立即点击 \u003cstrong\u003e“Increase sync”\u003c/strong\u003e 按钮，\u003ccode\u003ecount\u003c/code\u003e 只更新到 \u003ccode\u003e1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这是因为 \u003ccode\u003edelay()\u003c/code\u003e 是一个过时的闭包。\u003c/p\u003e\n\u003cp\u003e来看看这个过程发生了什么：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e初始渲染：\u003ccode\u003ecount\u003c/code\u003e 值为 \u003ccode\u003e0\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003e'Increase async'\u003c/strong\u003e 按钮。\u003ccode\u003edelay()\u003c/code\u003e 闭包捕获 \u003ccode\u003ecount\u003c/code\u003e 的值 \u003ccode\u003e0\u003c/code\u003e。\u003ccode\u003esetTimeout()\u003c/code\u003e 1 秒后调用 \u003ccode\u003edelay()\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003e“Increase async”\u003c/strong\u003e 按键。\u003ccode\u003ehandleClickSync()\u003c/code\u003e 调用 \u003ccode\u003esetCount(0 + 1)\u003c/code\u003e 将 \u003ccode\u003ecount\u003c/code\u003e 的值设置为 \u003ccode\u003e1\u003c/code\u003e，组件重新渲染。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1\u003c/code\u003e 秒之后，\u003ccode\u003esetTimeout()\u003c/code\u003e 执行 \u003ccode\u003edelay()\u003c/code\u003e 函数。但是 \u003ccode\u003edelay()\u003c/code\u003e 中闭包保存 \u003ccode\u003ecount\u003c/code\u003e 的值是初始渲染的值 \u003ccode\u003e0\u003c/code\u003e，所以调用 \u003ccode\u003esetState(0 + 1)\u003c/code\u003e，结果\u003ccode\u003ecount\u003c/code\u003e保持为 \u003ccode\u003e1\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003edelay()\u003c/code\u003e 是一个过时的闭包，它使用在初始渲染期间捕获的过时的 \u003ccode\u003ecount\u003c/code\u003e 变量。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，可以使用函数方法来更新 \u003ccode\u003ecount\u003c/code\u003e 状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction DelayedCount() {\n  const [count, setCount] = useState(0);\n\n  function handleClickAsync() {\n    setTimeout(function delay() {\n      setCount(count =\u003e count + 1); // 这行是重点\n    }, 1000);\n  }\n\n  function handleClickSync() {\n    setCount(count + 1);\n  }\n\n  return (\n    \u0026#x3C;div\u003e\n      {count}\n      \u0026#x3C;button onClick={handleClickAsync}\u003eIncrease async\u0026#x3C;/button\u003e\n      \u0026#x3C;button onClick={handleClickSync}\u003eIncrease sync\u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在 \u003ccode\u003esetCount(count =\u003e count + 1)\u003c/code\u003e 更新了 \u003ccode\u003edelay()\u003c/code\u003e 中的 \u003ccode\u003ecount\u003c/code\u003e 状态。React 确保将最新状态值作为参数提供给更新状态函数，过时的闭包的问题就解决了。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e闭包是一个函数，它从定义变量的地方(或其词法范围)捕获变量。闭包是每个 JS 开发人员都应该知道的一个重要概念。\u003c/p\u003e\n\u003cp\u003e当闭包捕获过时的变量时，就会出现过时闭包的问题。解决过时闭包的一个有效方法是正确设置 React Hook 的依赖项。或者，对于过时的状态，使用函数方式更新状态。\u003c/p\u003e\n\u003cp\u003e你认为闭包使得 React Hook 很难理解吗？\u003c/p\u003e\n\u003ch2\u003e来源\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e作者：Dmitri Pavlutin\u003cbr\u003e\n译者：前端小智\u003cbr\u003e\n来源：dmitripavlutin\u003cbr\u003e\n原文： \u003ca href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F\"\u003ehttps://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdmitripavlutin.com%2Fsimple-explanation-of-javascript-closures%2F\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n  "])</script><script>self.__next_f.push([1,"b:[\"$\",\"div\",null,{\"className\":\"article_pageBody__Bryg4\",\"children\":[[\"$\",\"$L14\",null,{\"menuItemList\":[{\"id\":0,\"label\":\"首页\",\"href\":\"/\",\"icon\":\"/icons/home_gray.svg\",\"iconSelected\":\"/icons/home_black.svg\"},{\"id\":1,\"label\":\"文章\",\"href\":\"/articles/all/1\",\"icon\":\"/icons/article_gray.svg\",\"iconSelected\":\"/icons/article_black.svg\"},{\"id\":3,\"label\":\"关于\",\"href\":\"/about\",\"icon\":\"/icons/about_gray.svg\",\"iconSelected\":\"/icons/about_black.svg\"},{\"id\":4,\"label\":\"搜索\",\"href\":\"/search\",\"icon\":\"/icons/search_gray.svg\",\"iconSelected\":\"/icons/search_black.svg\"}],\"currentSelectedLabel\":\"文章\"}],[\"$\",\"div\",null,{\"className\":\"article_pageBodyMain___x_AF\",\"children\":[[\"$\",\"$L15\",null,{}],[\"$\",\"div\",null,{\"className\":\"article_articleContainer__uRwUh scrollContent\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article_articleBody__0coIY scrollContent\",\"children\":[[\"$\",\"h1\",null,{\"style\":{\"marginBottom\":\"0.1rem\",\"marginTop\":\"0.2rem\"},\"children\":\"使用js和React Hook时的过时闭包问题及解决方案\"}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"tags_tags__qM_Ja\",\"children\":[[\"$\",\"p\",null,{\"className\":\"tags_label__Rg6b2\",\"children\":\"分类\"}],[[\"$\",\"$L16\",\"0\",{\"href\":\"/articles/新知笔记/1\",\"children\":[\"$\",\"p\",\"0\",{\"className\":\"tags_tag__HZYxk tags_tagLink__gnw9V\",\"children\":\"新知笔记\"}]}],[\"$\",\"$L16\",\"1\",{\"href\":\"/articles/前端技术/1\",\"children\":[\"$\",\"p\",\"1\",{\"className\":\"tags_tag__HZYxk tags_tagLink__gnw9V\",\"children\":\"前端技术\"}]}]],false]}],[\"$\",\"div\",null,{\"className\":\"tags_tags__qM_Ja\",\"children\":[[\"$\",\"p\",null,{\"className\":\"tags_label__Rg6b2\",\"children\":\"标签\"}],\"$undefined\",[[\"$\",\"p\",\"0\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"javascript\"}],[\"$\",\"p\",\"1\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"React\"}],[\"$\",\"p\",\"2\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"过时闭包\"}],[\"$\",\"p\",\"3\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"Hook\"}],[\"$\",\"p\",\"4\",{\"className\":\"tags_tag__HZYxk \",\"children\":\"解决方案\"}]]]}],[\"$\",\"$L17\",null,{\"path\":\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"serverURL\":\"https://remark.timeshike.com/\"}]]}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$18\"}}],[\"$\",\"$L19\",null,{}],[\"$\",\"$L1a\",null,{\"path\":\"%E4%BD%BF%E7%94%A8js%E5%92%8CReact-Hook%E6%97%B6%E7%9A%84%E8%BF%87%E6%97%B6%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\",\"serverURL\":\"https://remark.timeshike.com/\",\"lang\":\"zh-CN\"}],[\"$\",\"div\",null,{\"className\":\"bottomBar_bottomBar__uHU1W\",\"children\":[\"$\",\"div\",null,{\"className\":\"bottomBar_text__iz3cM\",\"children\":[\"Powerd by\",[\"$\",\"a\",null,{\"href\":\"https://github.com/hixyl/YlBlog\",\"target\":\"_blank\",\"children\":\" YlBlog(玉龙博客)\"}]]}]}]]}],[\"$\",\"$L1b\",null,{}]]}]]}],[\"$\",\"$L1c\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"使用js和React Hook时的过时闭包问题及解决方案 - 流年石刻\"}],[\"$\",\"meta\",\"3\",{\"name\":\"next-size-adjust\"}]]\na:null\n"])</script></body></html>